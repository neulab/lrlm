import contextlib
import os
from pathlib import Path
from typing import IO, TextIO, Union

from nnlib.utils.misc import progress

__all__ = ['shut_up', 'FileProgressWrapper', 'reverse_open']


@contextlib.contextmanager
def shut_up(stderr=True, stdout=False):
    """
    Suppress output (probably generated by external script or badly-written libraries) for stderr or stdout.
    :param stderr: If true, suppress output from stderr.
    :param stdout: If true, suppress output from stdout.
    """
    # redirect output to /dev/null
    fds = ([1] if stdout else []) + ([2] if stderr else [])
    null_fds = [os.open(os.devnull, os.O_RDWR) for _ in fds]
    output_fds = [os.dup(fd) for fd in fds]
    for null_fd, fd in zip(null_fds, fds):
        os.dup2(null_fd, fd)
    yield
    # restore normal stderr
    for null_fd, output_fd, fd in zip(null_fds, output_fds, fds):
        os.dup2(output_fd, fd)
        os.close(null_fd)


class FileProgressWrapper:
    def __new__(cls, f: TextIO, *, verbose=True, **kwargs):
        if not verbose:
            return f
        return super().__new__(cls)

    def __init__(self, f: TextIO, *, encoding='utf-8', **kwargs):
        self.f = f
        self.encoding = encoding
        self.file_size = os.fstat(f.fileno()).st_size
        self.progress_bar = progress(total=self.file_size, **kwargs)
        self.size_read = 0
        self._next_tick = 1
        self._next_size = self.file_size // 100
        self._accum_size = 0

    def __iter__(self):
        return self

    def _update(self, line: str):
        size = len(line.encode(self.encoding))
        self._accum_size += size
        if self.size_read + self._accum_size >= self._next_size:  # do a bulk update
            self.progress_bar.update(self._accum_size, )
            self.size_read += self._accum_size
            self._accum_size = 0
            while self.size_read >= self._next_size:
                self._next_tick += 1
                self._next_size = self.file_size * self._next_tick // 100

    def __next__(self) -> str:
        line = next(self.f)
        self._update(line)
        return line

    def readline(self, *args) -> str:
        line = self.f.readline(*args)
        self._update(line)
        return line

    def __enter__(self):
        self.f.__enter__()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.f.__exit__(exc_type, exc_val, exc_tb)


class _ReverseReadlineFile:
    MAX_CHAR_BYTES = 4  # Maximum length of byte sequences for any character in target encoding

    @staticmethod
    def generator(fp, *, encoding='ansi', allow_empty_lines=False, buf_size=8192):
        segment = None
        offset = 0

        fp.seek(0, os.SEEK_END)
        file_size = remaining_size = fp.tell()
        while remaining_size > 0:
            cur_buf_size = buf_size
            offset = min(file_size, offset + cur_buf_size)
            fp.seek(file_size - offset)
            buffer_bytes = fp.read(min(remaining_size, cur_buf_size))

            trials = 0
            while True:
                trials += 1
                try:
                    buffer = buffer_bytes.decode(encoding)
                    break
                except UnicodeDecodeError:
                    if trials >= _ReverseReadlineFile.MAX_CHAR_BYTES:
                        raise
                    buffer_bytes = buffer_bytes[1:]
                    cur_buf_size -= 1
                    offset -= 1
            fp.seek(file_size - offset)

            remaining_size -= cur_buf_size
            lines = buffer.split('\n')
            # the first line of the buffer is probably not a complete line so
            # we'll save it and append it to the last line of the next buffer
            # we read
            if segment is not None:
                # if the previous chunk starts right from the beginning of line
                # do not concat the segment to the last line of new chunk
                # instead, yield the segment first
                if buffer[-1] != '\n':
                    lines[-1] += segment
                else:
                    yield segment
            segment = lines[0]
            for index in range(len(lines) - 1, 0, -1):
                if allow_empty_lines or len(lines[index]):
                    yield lines[index]
        # Don't yield None if the file was empty
        if segment is not None:
            yield segment

    def __init__(self, fp: IO, gen):
        self.fp = fp
        self.gen = gen

    def __iter__(self):
        return self

    def __next__(self):
        return next(self.gen)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.fp.close()

    def readline(self):
        return next(self.gen) + '\n'

    def close(self):
        self.fp.close()


@contextlib.contextmanager
def reverse_open(path: Union[str, Path], *, encoding='ansi', allow_empty_lines=False, buf_size=8192):
    # Credits: https://stackoverflow.com/questions/2301789/read-a-file-in-reverse-order-using-python
    """a generator that returns the lines of a file in reverse order"""
    with Path(path).open('rb') as fp:
        gen = _ReverseReadlineFile.generator(fp, encoding=encoding, allow_empty_lines=allow_empty_lines,
                                             buf_size=buf_size)
        yield _ReverseReadlineFile(fp, gen)
